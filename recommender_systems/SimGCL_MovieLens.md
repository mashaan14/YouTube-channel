# SimGCL and MovieLens 100K

<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
</head>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/G6c6zk0RhRM" frameborder="0" allowfullscreen></iframe>
</div>

## Acknowledgement

To replicate SimGCL functionality, I adapted code from the [SELFRec](https://github.com/Coder-Yu/SELFRec/tree/144e6bc7afd22f667d45348c6c612ae1a2a41220) library, specifically [`SimGCL.py`](https://github.com/Coder-Yu/SELFRec/blob/main/model/graph/SimGCL.py) and [`loss_torch.py`](https://github.com/Coder-Yu/SELFRec/blob/main/util/loss_torch.py). As SELFRec is designed for multiple recommender systems, I used Grok to remove external dependencies, creating a self-contained Jupyter notebook. I compared the code generated by Grok with the official SimGCL implementation for accuracy and consistency.

## References

```bibtex
@inproceedings{he2020lightgcn,
  title     = {LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation},
  author    = {He, Xiangnan and Deng, Kuan and Xiang, Zhengyu and Wang, Yan and Liu, Yongdong and Chua, Tat-Seng},
  booktitle = {Proceedings of the 43rd International ACM SIGIR conference on research and development in Information Retrieval},
  pages     = {639--648},
  year      = {2020}
}
```

```bibtex
@inproceedings{10.1145/3404835.3462862,
  author    = {Wu, Jiancan and Wang, Xiang and Feng, Fuli and He, Xiangnan and Chen, Liang and Lian, Jianxun and Xie, Xing},
  title     = {Self-supervised Graph Learning for Recommendation},
  year      = {2021},
  booktitle = {Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval},
  pages     = {726â€“735},
  series    = {SIGIR '21}
}
```

```bibtex
@misc{yu2022graphaugmentations,
  title  = {Are Graph Augmentations Necessary? Simple Graph Contrastive Learning for Recommendation}, 
  author = {Junliang Yu and Hongzhi Yin and Xin Xia and Tong Chen and Lizhen Cui and Quoc Viet Hung Nguyen},
  year   = {2022},
  eprint = {2112.08679},
  url    = {https://arxiv.org/abs/2112.08679}
}
```

```bibtex
@ARTICLE{10158930,
  author  = {Yu, Junliang and Xia, Xin and Chen, Tong and Cui, Lizhen and Hung, Nguyen Quoc Viet and Yin, Hongzhi},
  journal = {IEEE Transactions on Knowledge \& Data Engineering},
  title   = {{XSimGCL: Towards Extremely Simple Graph Contrastive Learning for Recommendation}},
  year    = {2024},
  pages   = {913-926}
}
```

![SimGCL_MovieLens_005](https://github.com/user-attachments/assets/39e5551c-98fa-4122-a592-f122853c518e)

## LightGCN loss computation

![SimGCL_MovieLens_001](https://github.com/user-attachments/assets/5c1fec6e-299c-4ebc-a0c0-bfd5258064d7)


## SimGCL loss computation

![SimGCL_MovieLens_002](https://github.com/user-attachments/assets/69aed4c7-34b0-4320-8624-9e8bf8c9c744)

## BPR loss

Bayesian Personalized Ranking (BPR) loss, which is common in recommender systems, has two main components: (1) a term that compares scores for positive and negative item pairs, and (2) a regularization term, scaled by $\lambda$. The idea is to train the model to rank positive items higher.

![Untitled-001](https://github.com/user-attachments/assets/4e6ced41-2c6b-4613-bff6-b469367ca3f2)

![SimGCL_MovieLens_004](https://github.com/user-attachments/assets/329b904f-ca80-43d5-bd18-60cd295684d3)


## InfoNCE loss

InfoNCE, with NCE meaning Noise-Contrastive Estimation, works by minimizing the distance between a user/item's representations in two different views, and maximizing the distance to other users/items in those views.

![Untitled-002](https://github.com/user-attachments/assets/9d4206b6-389b-4dfb-8a60-63218fd5477b)

![SimGCL_MovieLens_003](https://github.com/user-attachments/assets/aac0a1b3-e7ec-4dfb-837d-fcbe07051274)


<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true}, // Display math (e.g., equations on their own line)
        {left: '$', right: '$', display: false},  // Inline math (e.g., within a sentence)
        {left: '\\(', right: '\\)', display: false}, // Another way to write inline math
        {left: '\\[', right: '\\]', display: true}   // Another way to write display math
      ]
    });
  });
</script>
